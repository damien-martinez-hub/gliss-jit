/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#ifndef GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H
#define GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H

#include <assert.h>
#include <$(proc)/api.h>
#include <$(proc)/macros.h>

#if defined(__cplusplus)
extern  "C"
{
#endif

/* TODO: add some error messages when malloc fails */
#define gliss_error(e) fprintf(stderr, "%s\n", (e))

/* hack : Enable cache if gep option is on 
(without having to  move decode32.c to templates) */
$(if GLISS_INF_DECODE_CACHE)
#define $(PROC)_INF_DECODE_CACHE
$(end)
$(if GLISS_FIXED_DECODE_CACHE)
#define $(PROC)_FIXED_DECODE_CACHE
$(end)
$(if GLISS_LRU_DECODE_CACHE)
#define $(PROC)_LRU_DECODE_CACHE
$(end)
$(if GLISS_DCACHE_WITH_INSTR_WORD)
#define $(PROC)_DCACHE_WITH_INSTR_WORD
$(end)
$(if GLISS_NO_MALLOC)
#define $(PROC)_NO_MALLOC
$(end)


/* decoder macros */
#define __EXTRACT(mask, offset_mask, inst)	  ( (uint32_t)((inst) & (mask)) >> (offset_mask))
#define __EXTS(mask, offset_mask, inst, n)    (((int32_t)__EXTRACT(mask, offset_mask, inst) << (n)) >> (n))

static$(if !GLISS_NO_MALLOC) $(proc)_inst_t *$(else) void $(end)$(proc)_instr_UNKNOWN_decode($(proc)_address_t address, uint32_t code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end))
{
$(if !GLISS_NO_MALLOC)
	$(proc)_inst_t *inst = malloc(sizeof($(proc)_inst_t));
	$(if !GLISS_PARAMS_NOMALLOC)inst->instrinput = malloc(sizeof($(proc)_ii_t) * 2);$(end)
$(end)
	inst->ident = $(PROC)_UNKNOWN;

	/* set size and address */
	$(if !GLISS_NO_PARAM)inst->instrinput[0].type = $(PROC)_ADDR;$(end)
	inst->instrinput[0].val.addr = address;
	$(if !GLISS_NO_PARAM)inst->instrinput[1].type = $(PROC)_SIZE;$(end)
	inst->instrinput[1].val.size = 32;

	$(if !GLISS_NO_MALLOC)return inst;$(end)
}

$(foreach instructions)
static$(if !GLISS_NO_MALLOC) $(proc)_inst_t *$(else) void $(end)$(proc)_instr_$(IDENT)_decode($(proc)_address_t address, uint32_t code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end))
{
	$(if has_param)uint32_t mask;
	
$(if !GLISS_NO_MALLOC)
$(if GLISS_ONE_MALLOC)
	$(proc)_inst_t *inst = ($(proc)_inst_t *)malloc(sizeof($(proc)_inst_t) $(if !GLISS_PARAMS_NOMALLOC) + sizeof($(proc)_ii_t) * ($(num_params) + 2) $(end));
	$(if !GLISS_PARAMS_NOMALLOC)inst->instrinput = ($(proc)_ii_t *)(inst + 1);$(end)
$(else)
		$(proc)_inst_t *inst = ($(proc)_inst_t *)malloc(sizeof($(proc)_inst_t));
		$(if !GLISS_PARAMS_NOMALLOC)inst->instrinput = malloc(sizeof($(proc)_ii_t) * ($(num_params) + 2));$(end)
$(end)
$(end)
	inst->ident = $(PROC)_$(IDENT);

	/* set size and address */
	$(if !GLISS_NO_PARAM)inst->instrinput[0].type = $(PROC)_ADDR;$(end)
	inst->instrinput[0].val.addr = address;
	$(if !GLISS_NO_PARAM)inst->instrinput[1].type = $(PROC)_SIZE;$(end)
	inst->instrinput[1].val.size = 32;

	/* put other parameters */
	$(foreach params)/* param number $(INDEX) */
	$(PROC)_$(IDENT)_$(PARAM) = $(decoder); /*valeur_sur_mask_bloc(code_inst, mask);*/ /* res->instrinput[$(INDEX)].val.$(param_type) */
	$(if !GLISS_NO_PARAM)inst->instrinput[$(INDEX) + 2].type = $(PROC)_PARAM_$(PARAM_TYPE)_T;$(end)
	$(end)
	$(if !GLISS_NO_MALLOC)return inst;$(end)
}

$(else)$(if !GLISS_NO_MALLOC)$(proc)_inst_t *inst = malloc(sizeof($(proc)_inst_t));
	$(if !GLISS_PARAMS_NOMALLOC)inst->instrinput = malloc(sizeof($(proc)_ii_t) * 2);$(end)
$(end)	
	inst->ident = $(PROC)_$(IDENT);

	/* set size and address */
	$(if !GLISS_NO_PARAM)inst->instrinput[0].type = $(PROC)_ADDR;$(end)
	inst->instrinput[0].val.addr = address;
	$(if !GLISS_NO_PARAM)inst->instrinput[1].type = $(PROC)_SIZE;$(end)
	inst->instrinput[1].val.size = 32;

	$(if !GLISS_NO_MALLOC)return inst;$(end)
}

$(end)
$(end)


typedef $(if !GLISS_NO_MALLOC)$(proc)_inst_t *$(else)void $(end)$(proc)_decode_function_t($(proc)_address_t address, uint32_t code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end));

static $(proc)_decode_function_t *$(proc)_decode_table[] =
{
	$(proc)_instr_UNKNOWN_decode$(foreach instructions),
	$(proc)_instr_$(IDENT)_decode$(end)
};

/* free a dynamically allocated instruction, we try not to free an already freed or NULL pointer */
void $(proc)_free_inst($(proc)_inst_t *inst) {
	assert(inst);
	$(if !GLISS_ONE_MALLOC)
		if (inst->instrinput)
			free(inst->instrinput);
	$(end)

	$(if !GLISS_INF_DECODE_CACHE)
    $(if !GLISS_FIXED_DECODE_CACHE)
    $(if !GLISS_LRU_DECODE_CACHE)
	  free(inst);
	$(end)
	$(end)
	$(end)
}

#if defined(__cplusplus)
}
#endif

#endif /* GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H */
