/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <$(proc)/fetch.h>
#include <$(proc)/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <$(proc)/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define $(proc)_error(e) fprintf(stderr, "%s\n", (e))


/* endianness */
typedef enum $(proc)_endianness_t {
  little = 0,
  big = 1
} $(proc)_endianness_t;

/* decode structure */
struct $(proc)_decoder_t
{
    /* the fetch unit used to retrieve instruction ID */
    $(proc)_fetch_t* fetch;
    #ifdef GLISS_NO_MALLOC
    $(proc)_inst_t*  tmp_inst;
    #endif
};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address);


/* initialization and destruction of $(proc)_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder($(proc)_decoder_t *d, $(proc)_platform_t *state)
{
        d->fetch = $(proc)_new_fetch(state);
        #ifdef GLISS_NO_MALLOC
        d->tmp_inst = ($(proc)_inst_t*)malloc(sizeof($(proc)_inst_t));
        #endif
}

static void halt_decoder($(proc)_decoder_t *d)
{
        $(proc)_delete_fetch(d->fetch);
        #ifdef GLISS_NO_MALLOC
        free(d->tmp_inst);
        #endif       
}

$(proc)_decoder_t *$(proc)_new_decoder($(proc)_platform_t *state)
{
    $(proc)_decoder_t *res = malloc(sizeof($(proc)_decoder_t));
    if (res == NULL)
                $(proc)_error("not enough memory to create a $(proc)_decoder_t object"); /* I assume error handling will remain the same, we use $(proc)_error istead of iss_error ? */
    /*assert(number_of_decode_objects >= 0);*/
    init_decoder(res, state);
    number_of_decoder_objects++;
    return res;
}

void $(proc)_delete_decoder($(proc)_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                $(proc)_error("cannot delete an NULL $(proc)_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}

$(if is_RISC)
/* Fonctions Principales */
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	uint$(C_inst_size)_t code;

	/* first, fetch the instruction at the given address */
	id = $(proc)_fetch(decoder->fetch, address, &code);
	/* then decode it */
#ifndef $(PROC)_NO_MALLOC
	res = $(proc)_decode_table[id](code);
#else
	res = decoder->tmp_inst;
	$(proc)_decode_table[id](code, res);
#endif
	res->addr = address;
    
	return res;
}
$(else)


/* Fonctions Principales */
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	mask_t code = {i_buff, 0};

	/* first, fetch the instruction at the given address */
	id = $(proc)_fetch(decoder->fetch, address, &code);
	/* then decode it */
#ifndef GLISS_NO_MALLOC
	res  = $(proc)_decode_table[id](&code);
#else
	res = decoder->tmp_inst;
	$(proc)_decode_table[id](&code, res);
#endif
	res->addr = address;
        
	return res;
}
$(end)

/* End of file $(proc)_decode.c */
