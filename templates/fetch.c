/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <$(proc)/mem.h>
#include <$(proc)/fetch.h>

#include "fetch_table.h"

#define $(proc)_error(e) fprintf(stderr, "%s\n", (e))


/* Extern Modules */
/* Constants */


/* Variables & Fonctions */

static void halt_fetch(void)
{
}


static void init_fetch(void)
{
}



/* initialization and destruction of $(proc)_fetch_t object */

static int number_of_fetch_objects = 0;


$(proc)_fetch_t *$(proc)_new_fetch($(proc)_platform_t *state)
{
	$(proc)_fetch_t *res = malloc(sizeof($(proc)_fetch_t));
	if (res == NULL)
		$(proc)_error("not enough memory to create a $(proc)_fetch_t object"); /* I assume error handling will remain the same, we use $(proc)_error istead of iss_error ? */
	res->mem = $(proc)_get_memory(state, GLISS_MAIN_MEMORY);
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}


void $(proc)_delete_fetch($(proc)_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		$(proc)_error("cannot delete an NULL $(proc)_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}

$(if is_RISC)
/*
	donne la valeur d'une zone mémoire (une instruction) en ne prenant
	en compte que les bits indiqués par le mask

	on fait un ET logique entre l'instruction et le masque,
	on conserve seulement les bits indiqués par le masque
	et on les concatène pour avoir un nombre sur bits

	on suppose que le masque n'a pas plus de $(C_inst_size) bits à 1,
	sinon débordement

	instr : instruction (de $(C_inst_size) bits)
	mask  : masque ($(C_inst_size) bits aussi)
*/
static uint$(C_inst_size)_t valeur_sur_mask_bloc(uint$(C_inst_size)_t instr, uint$(C_inst_size)_t mask)
{
	int i;
	uint$(C_inst_size)_t tmp_mask;
	uint$(C_inst_size)_t res = 0;

	/* on fait un parcours du bit de fort poids de instr[0]
	à celui de poids faible de instr[nb_bloc-1], "de gauche à droite" */

	tmp_mask = mask;
	for (i = $(C_inst_size) - 1; i >= 0; i--)
	{
		/* le bit i du mask est 1 ? */
		if (tmp_mask & $(msb_mask))
		{
			/* si oui, recopie du bit i de l'instruction
			à droite du resultat avec decalage prealable */
			res <<= 1;
			res |= ((instr >> i) & 0x01);
		}
		tmp_mask <<= 1;
	}
	return res;
}


/* Fonctions Principales */
$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address, uint$(C_inst_size)_t code)
{
	uint$(C_inst_size)_t valeur;
	Table_Decodage *ptr;
	Table_Decodage *ptr2;

	ptr2 = table;
	do
	{
                valeur = valeur_sur_mask_bloc(code, ptr2->mask0);
                ptr  = ptr2;
		ptr2 = ptr->table[valeur].ptr;
	}
	while (ptr->table[valeur].type == TABLEFETCH);

	return ($(proc)_ident_t)ptr->table[valeur].ptr;
}
$(else)

/* here we deal with variable size instructions (CISC) */

/* struct used to store masks and as buffer for instruction codes */
/* chunks are arranged in the same order as in memory, msb first, lsb last */
typedef struct {
	uint32_t *mask;
	int bit_length;
} mask_t;


/* shift a mask 1 bit to the left and add a given bit to the right,
 * mask should be long enough to add one bit */
/*static void mask_left_shift_add_bit(mask_t *mask, uint32_t new_lsb)
{
	mask->bit_length++;
	int n = (mask->bit_length / 32) + ((mask->bit_length % 32)? 1: 0);
	uint32_t b1 = new_lsb, b2;
	
	for (int i = 0; i < n; i++) {
		b2 = b1;
		b1 = (0x80000000 & mask->mask[i]) >> 31;
		mask->mask[i] = (mask->mask[i] << 1) | b2;
	}
}*/

/* return bit n of a mask, result (0 or 1) is right justified in an uint32_t */
static uint32_t get_bit_n(mask_t *mask, int n)
{
	if (n >= mask->bit_length)
		/* index out of range, should be an error */
		return 0;
	int bit_idx = n % 32;
	int idx = n / 32 + (bit_idx? 1: 0);
	return ((mask->mask[idx] >> bit_idx) & 1)
}

/*static void set_bit_n(mask_t *mask, int n, uint32_t bit)
{
	if (n >= mask->bit_length)
		return;
	int bit_idx = n % 32;
	int idx = n / 32 + (bit_idx? 1: 0);
	uint64_t bit_mask = 1 << bit_idx;
	mask->mask[idx] = (mask->mask[idx] & ~bit_mask) | (bit? bit_mask: 0);
}*/

/* generic version of valeur_sur_mask_bloc
 * inst->bit_length should be >= to mask->bit_length. we hope the result is 32 bit max as
 * it needs to be used as an array index so it mustn't be too huge or the fetch algorithm might be changed
 */
static uint32_t value_on_mask(mask_t *inst, mask_t *mask)
{
	uint32_t res = 0;
	int k = 0;
	for (int i = mask->bit_length - 1; i >= 0; i++) {
		if (get_bit_n(mask, i)) {
			k++;
			if (k > 32)
				/* should be an error */
				$(proc)_error("ERROR: a value on mask is more than 32 bit long\n");
			res = ((res << 1) | get_bit_n(inst, i));
		}
	}
}


/* Fonctions Principales */
$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address)
{
	uint32_t value;
	
	Table_Decodage *ptr;
	Table_Decodage *ptr2;
	/* init a buffer for the read instr, size should max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	mask_t inst_buff = {i_buff, 0};
	ptr2 = table;
	do
	{
		/* if inst_buffer has not enough bits to apply mask, read and add what's needed, read a chunk (like in mask_t) at a time */
		while (inst_buff->bit_length < ptr2->mask->bit_length) {
			i_buff[inst_buff->bit_length >> 5] = $(proc)_mem_read32(fetch->mem, address + (inst_buff->bit_length >> 2));
			inst_buff->bit_length += 32;
		}
			
		/* compute value on mask */
		value = value_on_mask(&inst_buff, ptr2->mask);
                ptr  = ptr2;
		ptr2 = ptr->table[value].ptr;
	}
	while (ptr->table[value].type == TABLEFETCH);

	return ($(proc)_ident_t)ptr->table[value].ptr;
}
$(end)
/* End of file $(proc)_fetch.c */
