/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <gliss/mem.h>
#include <gliss/fetch.h>

#include "fetch_table.h" /* or ../include/gliss/ ? */

#define gliss_error(e) fprintf(stderr, "%s\n", (e))

/* endianness */
typedef enum gliss_endianness_t {
  little = 0,
  big = 1
} gliss_endianness_t;

/* Extern Modules */
/* Constants */


/* Variables & Fonctions */


static int instr_is_free[GLISS_MAX_INSTR_FETCHED];
static gliss_inst_t instr_tbl[GLISS_MAX_INSTR_FETCHED];




static void halt_fetch(void)
{
}

static void init_fetch(void)
{
	int i;

	for (i = 0; i < GLISS_MAX_INSTR_FETCHED; i++)
		instr_is_free[i] = 1;
}



/* initialization and destruction of gliss_fetch_t object */

static int number_of_fetch_objects = 0;

gliss_fetch_t *gliss_new_fetch(gliss_platform_t *state)
{
	gliss_fetch_t *res = malloc(sizeof(gliss_fetch_t));
	if (res == NULL)
		gliss_error("not enough memory to create a gliss_fetch_t object"); /* I assume error handling will remain the same, we use gliss_error istead of iss_error ? */
	res->mem = gliss_get_memory(state, GLISS_MAIN_MEMORY);
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}

void gliss_delete_fetch(gliss_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		gliss_error("cannot delete an NULL gliss_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}

/*
	donne la valeur d'une zone mémoire (une instruction) en ne prenant
	en compte que les bits indiqués par le mask

	on fait un ET logique entre l'instruction et le masque,
	on conserve seulement les bits indiqués par le masque
	et on les concatène pour avoir un nombre sur 32 bits

	on suppose que le masque n'a pas plus de 32 bits à 1,
	sinon débordement

	instr : instruction (de 32 bits)
	mask  : masque (32 bits aussi)
*/
static uint32_t valeur_sur_mask_bloc(uint32_t instr, uint32_t mask)
{
	int i;
	uint32_t tmp_mask;
	uint32_t res = 0;

	/* on fait un parcours du bit de fort poids de instr[0]
	à celui de poids faible de instr[nb_bloc-1], "de gauche à droite" */

	tmp_mask = mask;
	for (i = 31; i >= 0; i--)
	{
		/* le bit i du mask est 1 ? */
		if (tmp_mask & 0x80000000UL)
		{
			/* si oui, recopie du bit i de l'instruction
			à droite du resultat avec decalage prealable */
			res <<= 1;
			res |= ((instr >> i) & 0x01);
		}
		tmp_mask <<= 1;
	}
	return res;
}


/* Fonctions Principales */
gliss_ident_t gliss_fetch(gliss_fetch_t *fetch, gliss_address_t address, uint32_t code)
{
	int valeur;
	Table_Decodage *ptr;
	Table_Decodage *ptr2;

	ptr2 = table;
	do
	{
                valeur = valeur_sur_mask_bloc(code, ptr2->mask0);
                ptr  = ptr2;
		ptr2 = ptr->table[valeur].ptr;
	}
	while (ptr->table[valeur].type == TABLEFETCH);

	return (gliss_ident_t)ptr->table[valeur].ptr;
}

/* End of file gliss_fetch.c */
