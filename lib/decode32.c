/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <gliss/fetch.h>
#include <gliss/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <gliss/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define gliss_error(e) fprintf(stderr, "%s\n", (e))


/* endianness */
typedef enum gliss_endianness_t {
  little = 0,
  big = 1
} gliss_endianness_t;

/* decode structure */
struct gliss_decoder_t
{
    /* the fetch unit used to retrieve instruction ID */
    gliss_fetch_t* fetch;
    #ifdef GLISS_NO_MALLOC
    gliss_inst_t*  tmp_inst;
    #endif
};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
gliss_inst_t *gliss_decode(gliss_decoder_t *decoder, gliss_address_t address);


/* initialization and destruction of gliss_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(gliss_decoder_t *d, gliss_platform_t *state)
{
        d->fetch = gliss_new_fetch(state);
        #ifdef GLISS_NO_MALLOC
        d->tmp_inst = (gliss_inst_t*)malloc(sizeof(gliss_inst_t));
        #endif
}

static void halt_decoder(gliss_decoder_t *d)
{
        gliss_delete_fetch(d->fetch);
        #ifdef GLISS_NO_MALLOC
        free(d->tmp_inst);
        #endif       
}

gliss_decoder_t *gliss_new_decoder(gliss_platform_t *state)
{
    gliss_decoder_t *res = malloc(sizeof(gliss_decoder_t));
    if (res == NULL)
                gliss_error("not enough memory to create a gliss_decoder_t object"); /* I assume error handling will remain the same, we use gliss_error istead of iss_error ? */
    /*assert(number_of_decode_objects >= 0);*/
    init_decoder(res, state);
    number_of_decoder_objects++;
    return res;
}

void gliss_delete_decoder(gliss_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                gliss_error("cannot delete an NULL gliss_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}


/* Fonctions Principales */
gliss_inst_t *gliss_decode(gliss_decoder_t *decoder, gliss_address_t address)
{
    gliss_inst_t*  res = 0;
    gliss_ident_t  id;
    uint32_t     code;

    /* first, fetch the instruction at the given address */
/* for genericity: only fetch should read instead and return the read inst to decode */
    code = gliss_mem_read32(decoder->fetch->mem, address);
    id   = gliss_fetch(decoder->fetch, address, code);
    /* then decode it */
    #ifndef GLISS_NO_MALLOC
    res  = gliss_decode_table[id](code);
    #else
    res = decoder->tmp_inst;
    gliss_decode_table[id](code, res);
    #endif
    res->addr = address;
        
    return res;
}

/* End of file gliss_decode.c */
