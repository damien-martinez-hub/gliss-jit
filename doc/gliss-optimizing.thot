====== Optimizing ======

In this section you will learn how to use several optimisation options.
You can can increase dramatically the simulator speed so pay attention !

===== Simulator's options ===== 

==== profiling ====

When running your simulation with the GLISS librairie through the generated main,
you can activate option :
<code>
-p or -profile=path_name
</code>
This option produce a profiling file which contains statistics about instructions number of calls.
Here is the head file format :
<code>
profiling statistics generated by GLISS2 for :
PROC_NAME
| instruction name | instruction identifier (cf. module id.h) | call count |
</code>
The rest of the file would be a list sort by descending number of instruction's calls.
For instance :
<code>
PPC_LWZ_RD_D_LP_RD_RP_ 1 1066162
PPC_OR_RD_RD_RD 2 533975
PPC_STW_RD_D_LP_RD_RP_ 3 414441
PPC_RLWINM_RD_RD_D_D_D 4 364428
// And so on for the rest of the NML instruction set...
</code>

If -p option is to be used, the simulator seek for an existing profiling file
and add new statistics to the old one. If the file doesn't exists it will be created.
You can also specify the profiling file path with '-profile=path'.

N.B : This option is not an optimisation itself of course.
but the profiling file will be usefull for what's coming.
He can also help see which instruction deserved more optimisation inside the NML.
Bad NML implementation leads to bad performance, it is something to keep in mind. 

==== statistics ====

Default simulator's main provide two option statistics options in order to guide you in your quest of speed :

<code>
-s or stat
-more-stats
</code>

'-s' display the time of the simulation and the speed in Mips.
Measure is taken with the function 'rusage' (see linux man pages).
Speed and time are computed with the process user time.

-more-stats display the process system time thanks to rusage.
It also display speed and time with the function 'getgettimeofday' (see linux man pages).

==== full speed simulation ====

Through api.h GLISS provides severals methods to simulate a programm.
<code>

</code>

<code>
-f or -fast 
</code>


===== GEP's options =====


==== Faster modules ====


      decode32 module original sans cache
    *
      decode32_inf_cache cache avec hashtable de taille infinie
    *
      decode32_fixed_cache cache avec hashtable de taille fixe (tableau 2D)
    *
      decode32_lru_cache cache fixe avec écrasement selon la lru (tableau de liste chaînés)
    *
      decode32_trace cache de bloque réguliers d’instructions
    *
      decode32_dtrace (le plus rapide) trace de longueurs “dynamiques” (avec un buffer de taille fixe pre-alloué)
    *
      vfast_mem.c est le module implémentant l’optimisation des indiens avec une hashtable de un niveau (cf doc )

==== Generation options ==== 

==== GLISS_INSTR_FAST_STRUCT ====



=== GLISS_NO_MALLOC ===

mallocs de décodage fait à l’initialisation du cache uniquement

=== -p path ===

permet d’indiquer à gep où ce trouve le fichier de profiling généré par un simulateur.
Ce fichier regroupe par ordre décroissant le nombre d’appel de chaque instruction.
Cela permet de trier les fichiers C générés,
optimisant ainsi les accès au cache de la machine hôte.

=== -PJ nb_instr ===

PJ pour ‘profiled jumps’.
Inline nb_instr handler d’instructions dans la boucle d’interprétation avec un simple switch.
Ce sont les les nb_instr instructions les plus utilisés qui sont inliné.
Pour cela l’option -p doit être aussi satisfaite.

=== gen-with-trace ===

Génère en tenant compte des attributs ‘set_attr_branch = 1’ dans le NML,
cela rend possible le décodage par trace dynamique dans le simulateur. le module decode32_dtrace doit être impérativement utilisé, et les branchements dans le NML correctement taggé.
