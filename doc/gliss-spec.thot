====== NML @(GLISS) Extensions ======

This section describes the extension of @(GLISS) to the NMP language.

===== State Attributes =====

In @(GLISS), some properties may be linked to state declarations
(registers, memories, etc) thanks to attributes. This properties are
used to generate the simulator or to express specific informations.

An attribute is declared with the following syntax:
<code>
StateAttribute ::= "__attr" "(" Attr ")"
Attr ::= IDENTIFIER | IDENTIFIER "(" AttrArg* ")"
AttrArg ::= Attr | Constant
</code>

Any application using the IRG implementation of @(GLISS) can have
access to the state attribute definitions that may be used for any goal.

In @(GLISS), the following attributes are used:

^ Attribute ^ Description ^
| ''pc'' | designs the register containing the address of the instruction to execute |


===== Specific Symbols =====

To manage its work, @(GLISS) uses a set of symbols defined in the NMP
file.

==== Processor Name ====

The ISA name (often the microprocessor name) is given through
the constant definition of ''proc'' symbol, expressed as a string.

For example, the PowerPC ISA may be defined as below:
<code>
let proc = "ppc"
</code>



==== Bit Order Definition ====

There is no standard for the order of bits in the instruction representation
as used either in bit fields, or in image format. To define this,
the constant definition ''bit_order'' can be used. It can only takes
two values:
  * "UPPERMOST" -- the left bit is the upper most bit (default)
  * "LOWERMOST" -- the left bit is the lower most bit.



==== Instruction Size ====

An important issue in defining the ISA images is to not forget constants
bits or to errors in image size. To prevent this, one can define the list
of supported sizes in the ''gliss_isize'' definition. This constant
takes as value a string where all possible size are listed separated
by commas.

If the @(GLISS) detects an instruction image size that does not fit
any sizes in the ''gliss_isize'' definition, the run will stop and
display all details about the error.

For example, a 32-bits fixed-size ISA is declared by:
<code>
let gliss_isize="32"
</code>

In the opposite, the TriCore ISA supports two sizes of instructions,
16-bits and 32-bits, is declared by:
<code>
let gliss_isize="32,16"
</code>



===== Declaration of canonical functions =====

These C functions, defined in external C files and used in NMP files, cannot get
correctly typed as is. To ensure type verification of operands and result, you have
to give a prototype of each canonical function in the NML file(s) where it is used.
Writing such a prototype in NML is done with the ''canon'' keyword like in these examples:

First we define some types to make things more readable,
<code>
type f32 = float(23, 9)
type u32 = card(32)
</code>

Then we can define functions with one, several or no argument,
<code>
canon f32 "fsqrt32"(f32)
canon f32 "fmul32"(f32, f32)
canon u32 "rand"()
</code>

or procedures with zero or more arguments.
<code>
canon "print_msg"(string)
canon "do_stuff_with_several_things"(u32, f32, u32, card(5))
</code>

Finally, we can also declare canonical external constants or variables:
<code>
canon "NULL" : card(32);
</code>

Here is the syntax:
<code>
CanonicFunctionDefinition ::= 'canon' TypeResult function_name '(' TypeParams? ')'

TypeResult ::= TypeExpr		// NML type of the result
TypeParams ::=				// NML type of the params
		TypeExpr
	|	TypeParams ',' TypeExpr
function_name ::= string	// name of the canonical function
</code>

**WARNING** Whatever you call or declare an canonical, do not forget
to put a pair of '"' around the name.


