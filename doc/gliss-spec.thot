====== NML @(GLISS) Extensions ======

This section describes the extension of @(GLISS) to the NMP language.

===== State Attributes =====

In @(GLISS), some properties may be linked to state declarations
(registers, memories, etc) thanks to attributes. This properties are
used to help the generation of the simulator or to express specific information.
Such an attribute is declared as attributes of ''op'' and ''mode'' specifications.

Any application using the IRG implementation of @(GLISS) can have
access to the state attribute definitions and this attributes may be used for any goal.

In @(GLISS) V2, the following attributes are used:

^ Attribute ^ Description ^
| ''pc'' = 1 | designs the program counter (address of executed instruction) |
[ ''fmt'' = STRING) | defines a string format to display the register name |
|  | (if register is multiple, the string must contains a ''%d'') |


===== Specific Symbols =====

To control its work, @(GLISS) V2 uses a set of symbols defined in the NMP
file.

==== Processor Name ====

The ISA name (often the microprocessor name) is given through
the constant definition of ''proc'' symbol, expressed as a string.

For example, the PowerPC ISA may be defined as below:
<code>
let proc = "ppc"
</code>



==== Bit Order Definition ====

There is no standard for the order of bits in the instruction representation
as used either in bit fields, or in image format. To define this,
the constant definition ''bit_order'' can be used. It can only takes
two values:
  * "UPPERMOST" -- the leftmost bit is the uppermost bit (default)
  * "LOWERMOST" -- the leftmost bit is the lowermost bit.



==== Instruction Size ====

An important issue in defining the ISA images is to not forget constants
bits or to perform mistakes in image size. To prevent this, one can define the list
of supported sizes in the ''gliss_isize'' definition. This constant
takes as value a string where all possible size are listed separated
by commas.

If the @(GLISS) V2 detects an instruction image size that does not fit
one of sizes in the ''gliss_isize'' definition, the generation stops and
displays details about the error.

For example, a 32-bits fixed-size ISA is declared by:
<code>
let gliss_isize="32"
</code>

In the opposite, the TriCore ISA supports two sizes of instructions,
16-bits and 32-bits and ''gliss_isize'' is declared as:
<code>
let gliss_isize="32,16"
</code>



===== Declaration of canonical functions =====

Canonical functions are C functions, defined in external C files and used in NMP files
but they cannot be correctly typed as is. To ensure type verification of operands and result, you have
to give a prototype of each canonical function in the NML file(s) where they are used.
Writing such a prototype in NML is done with the ''canon'' keyword as in these examples:

First we define some types to make things more readable,
<code>
type f32 = float(23, 9)
type u32 = card(32)
</code>

Then we can define functions with one, several or no argument,
<code>
canon f32 "fsqrt32"(f32)
canon f32 "fmul32"(f32, f32)
canon u32 "rand"()
</code>

or procedures with zero or more arguments.
<code>
canon "print_msg"(string)
canon "do_stuff_with_several_things"(u32, f32, u32, card(5))
</code>

Finally, we can also declare canonical external constants or variables:
<code>
canon card(32) "NULL"
</code>

Here is the syntax:
<code>
CanonicFunctionDefinition ::= 'canon' TypeResult function_name ('(' TypeParams? ')')?

TypeResult ::= TypeExpr		// NML type of the result
TypeParams ::=				// NML type of the params
		TypeExpr
	|	TypeParams ',' TypeExpr
function_name ::= string	// name of the canonical function
</code>

**WARNING** Whatever the canonical you declare, do not forget
to put a pair of '"' around the name.


===== Definition of several instruction sets in the same description =====

Some processors supports more than one instruction set. For example, the ARM processor family
supports its default 32-bit instruction set
and several pure 16-bit (THUMB1) or 16-bit/32-bit mixed THUMB2 instruction set.
According to its state, such a processor can pass from a decoding scheme to the another one,
just with a special instruction. As codes compiled for different instruction sets can be
mixed into a single program, we added the support for multiple instruction sets in a same description.

If several instruction sets have to be defined in a same descritpion, you just need to change the root
node from ''instruction'' to ''multi'', each child of this operation and its resulting tree is considered as
autonomous instruction set and a separate fetch tables is generated for each one.

Each node from the resulting tree of a child of the ''multi'' node must have specific attributes defined
to drive the fetch process. Practically, these attribute should be defined
directly at the root of the child a sub-trees, ie. in a direct child of ''multi''):
  * ''instruction_set_select'': boolean (or boolean like) expression based on processor register values,
it will be translated into C sources and evaluated to know if a given instruction set has to be used
to fecth and decode the next instruction,
  * ''instruction_set_name'': name of the defined instruction set, in a human readable form.

**Example with the ARM processor (standard and THUMB instruction set)**

<code>
op multi = ARM | THUMB  // and not op instruction!

op ARM(x : ARM_instr)
	image = x.image
	syntax = x.syntax
	action = {
                PIA = CIA;
                CIA = NIA;
                NIA = NIA + 4;
		x.action;
	}
	instruction_set_select = TFLAG == 0 // ARM mode if state bit TFLAG is cleared
	instruction_set_name = "ARM"        // human readable name for the ARM instruction set

              
op ARM_instr = ... // (tree of ARM instructions)

op THUMB(x : THUMB_instr)
	image = x.image
	syntax = x.syntax
	action = {
                PIA = CIA;
                CIA = NIA;
                NIA = NIA + 2;
		x.action;
	}
	instruction_set_select = TFLAG == 1 // THUMB mode if state bit TFLAG is set
	instruction_set_name = "THUMB"      // human readable name

op THUMB_instr = ... // (tree of ARM instructions)
</code>

