====== NML @(GLISS) Extensions ======

This section describes the extension of @(GLISS) to the NMP language.

===== State Attributes =====

In @(GLISS), some properties may be linked to state declarations
(registers, memories, etc) thanks to attributes. This properties are
used to generate the simulator or to express specific informations.

An attribute is declared with the following syntax:
<code>
StateAttribute ::= "__attr" "(" Attr ")"
Attr ::= IDENTIFIER | IDENTIFIER "(" AttrArg* ")"
AttrArg ::= Attr | Constant
</code>

Any application using the IRG implementation of @(GLISS) can have
access to the state attribute definitions that may be used for any goal.

In @(GLISS), the following attributes are used:

^ Attribute ^ Description ^
| ''pc'' | designs the register containing the address of the instruction to execute |


===== Specific Symbols =====

To manage its work, @(GLISS) uses a set of symbols defined in the NMP
file.

==== Processor Name ====

The ISA name (often the microprocessor name) is given through
the constant definition of ''proc'' symbol, expressed as a string.

For example, the PowerPC ISA may be defined as below:
<code>
let proc = "ppc"
</code>



==== Bit Order Definition ====

There is no standard for the order of bits in the instruction representation
as used either in bit fields, or in image format. To define this,
the constant definition ''bit_order'' can be used. It can only takes
two values:
  * "UPPERMOST" -- the left bit is the upper most bit (default)
  * "LOWERMOST" -- the left bit is the lower most bit.



==== Instruction Size ====

An important issue in defining the ISA images is to not forget constants
bits or to errors in image size. To prevent this, one can define the list
of supported sizes in the ''gliss_isize'' definition. This constant
takes as value a string where all possible size are listed separated
by commas.

If the @(GLISS) detects an instruction image size that does not fit
any sizes in the ''gliss_isize'' definition, the run will stop and
display all details about the error.

For example, a 32-bits fixed-size ISA is declared by:
<code>
let gliss_isize="32"
</code>

In the opposite, the TriCore ISA supports two sizes of instructions,
16-bits and 32-bits, is declared by:
<code>
let gliss_isize="32,16"
</code>



===== Declaration of canonical functions =====

These C functions, defined in external C files and used in NMP files, cannot get
correctly typed as is. To ensure type verification of operands and result, you have
to give a prototype of each canonical function in the NML file(s) where it is used.
Writing such a prototype in NML is done with the ''canon'' keyword like in these examples:

First we define some types to make things more readable,
<code>
type f32 = float(23, 9)
type u32 = card(32)
</code>

Then we can define functions with one, several or no argument,
<code>
canon f32 "fsqrt32"(f32)
canon f32 "fmul32"(f32, f32)
canon u32 "rand"()
</code>

or procedures with zero or more arguments.
<code>
canon "print_msg"(string)
canon "do_stuff_with_several_things"(u32, f32, u32, card(5))
</code>

Finally, we can also declare canonical external constants or variables:
<code>
canon "NULL" : card(32);
</code>

Here is the syntax:
<code>
CanonicFunctionDefinition ::= 'canon' TypeResult function_name '(' TypeParams? ')'

TypeResult ::= TypeExpr		// NML type of the result
TypeParams ::=				// NML type of the params
		TypeExpr
	|	TypeParams ',' TypeExpr
function_name ::= string	// name of the canonical function
</code>

**WARNING** Whatever you call or declare an canonical, do not forget
to put a pair of '"' around the name.


===== Definition of several instruction sets in a same description =====

Some processors supports more than one instruction set (see the ARM with his default 32-bit instruction set
and several pure 16-bit or 16-bit 32-bit mixed THUMB instruction set) and can pass from one to the other
decoding scheme just with a special instruction, as codes compiled for different instruction sets can be
mixed into a single program, we added the support for multiple instruction sets in a same description.

If several instruction sets are to be defined in a same descritpion, you just need to change the root
node from ''instruction'' to ''multi'', each son and its resulting tree will be considered an
autonomous instruction set and a set of fetch tables will be ouput for each one.

Each node from the resulting tree of a son of the ''multi'' node must have some attribute defined (practically, they should be defined
directly at the root of such a sub-tree, ie. in a direct son of ''multi''), here is the list:
  * ''instruction_set_select'': boolean (or boolean like) expression based on processor register values, it will be translated in generated C sources
  and evaluated to know if a given instruction set is to be used o fecth and decode the next instruction.
  * ''instruction_set_name'': name of the defined instruction set, in a humanly readable form.

Example with the ARM processor (standard and THUMB instruction set):

<code>
op multi = ARM | THUMB  // and not op instruction!

op ARM(x : ARM_instr)
	image = x.image
	syntax = x.syntax
	action = {
                PIA = CIA;
                CIA = NIA;
                NIA = NIA + 4;
		x.action;
	}
	instruction_set_select = TFLAG == 0 // ARM mode if state bit TFLAG is cleared
	instruction_set_name = "ARM"        // human readable name for the ARM instruction set

              
op ARM_instr = ... // (tree of ARM instructions)

op THUMB(x : THUMB_instr)
	image = x.image
	syntax = x.syntax
	action = {
                PIA = CIA;
                CIA = NIA;
                NIA = NIA + 2;
		x.action;
	}
	instruction_set_select = TFLAG == 1 // THUMB mode if state bit TFLAG is set
	instruction_set_name = "THUMB"      // human readable name

op THUMB_instr = ... // (tree of ARM instructions)
</code>

