
// ========================================================================= //
// 1. Definitions                                                            //
// ========================================================================= //

let proc = "toto"         
let bit_order = "uppermost" // Be careful ; this is not the convention used in PPC manuals.

// ------------------------------------------------------------------------- //
// 1.1 Constants                                                             //
// ------------------------------------------------------------------------- //

let REGS = 5



// ------------------------------------------------------------------------- //
// 1.2 Types                                                                 //
// ------------------------------------------------------------------------- //

type u8		= card ( 8 )
type u16	= card(16)
type u32	= card ( 32 )
type u64	= card ( 64 )

type u1		= card ( 1 )
type u2		= card(2)
type u4		= card ( 4 )
type u20	= card(20)
type u47	= card(47)

type s8		= int ( 8 )
type s16	= int(16)
type s32	= int ( 32 )
type s64	= int ( 64 )

type s2		= int(2)
type s4		= int ( 4 )
type s20	= int(20)
type s47	= int(47)

type fx2_2	= fix(2, 2)
type fx2_6	= fix(2, 6)
type fx6_2	= fix(6, 2)
type fx16_8	= fix(16, 8)
type fx8_16	= fix(8, 16)
type fx16_16	= fix(16, 16)
type fx22_10	= fix(22, 10)
type fx10_22	= fix(10, 22)
type fx40_24	= fix(40, 24)
type fx24_40	= fix(24, 40)

type rg0_255	= [0..255]
type rg_127_128 = [-127..128]
type rg0_10000	= [0..10000]
type rg_1000_100	= [-10000..-100]
type rg_X_X	= [-1000000000..1000000000]

type rg23_453	= [23..453]
type rg2_2	= [2..2]
type rg0_1	= [0..1]

type flot      = float ( 52 , 12 )
type flots     = float ( 23 , 9 )
type xflot     = float ( 64 , 16 )
type sflot     = float ( 31 , 9 )

// ------------------------------------------------------------------------- //
// 1.3  Memory and registers                                                 //
// ------------------------------------------------------------------------- //

// 1.3.1 GEP registers

reg PIA     [ 1 , s32 ]	__attr(ppc)
reg CIA     [ 1 , s32 ]	__attr(pc)
reg NIA     [ 1 , s32 ]	__attr(npc)

mem M		[ 32 , u8 ]

// ordinary sizes
reg R8		[8, u8]
reg R8s		[8, s8]
reg R16		[16, u16]
reg R16s	[16, s16]
reg R32s	[ 2 ** REGS , s32 ]
reg R32		[ 2 ** REGS , u32 ]
reg R64s	[ 2 ** REGS , s64 ]
reg R64		[ 2 ** REGS , u64 ]

// "exotic" sizes
reg R2		[ 8 , u2 ]
reg R2s		[ 8, s2]
reg R4		[ 8 , u4 ]
reg R4s		[ 8, s4]
reg R20		[ 8 , u20 ]
reg R20s	[ 8, s20]
reg R47		[ 8 , u47 ]
reg R47s	[ 8, s47]


reg FPR		[ 2 ** REGS , flot ]




// ------------------------------------------------------------------------- //
// 1.4  Internal variables and aliases for subparts                          //
// ------------------------------------------------------------------------- //








// ------------------------------------------------------------------------- //
// 1.5 Addressing Modes                                                      //
// ------------------------------------------------------------------------- //




// juste pour tester
mode _A = _B | _C | _D

mode _B(n:int(6)) = n
	syntax = format("B%d", n)
	image  = format("00%6b", n)

mode _C(n:int(6)) = n
	syntax = format("C%d", n)
	image  = format("01%6b", n)

mode _D = _E | _F

mode _E(n:int(6)) = n
	syntax = format("E%d", n)
	image  = format("10%6b", n)

mode _F(n:int(6)) = n
	syntax = format("F%d", n)
	image  = format("11%6b", n)



// ------------------------------------------------------------------------- //
// 1.6 Macros                                                                //
// ------------------------------------------------------------------------- //





		
// ========================================================================= //
//  2. Instructions                                                          //
// ========================================================================= //

op instruction ( x : allinstr)
  syntax = x.syntax
  image = x.image
  action = { x.action ; }

op allinstr = opA | opB | tmp_test

op tmp_test(p: card(8))
	syntax = format("test %d", p)
	image = format("10010001 %5b xxxxxxxx xxxxxxxx", p)
// !!BUG!! format("10010001 %5b", p) -> p : card(32)
	action = {
	}

op opA(x: card(5), y : card(5), z : card(5))
	syntax = format("opA %d,%d,%d", x, y, z)
	image = format("010111111%5b%5b%5b", x, y, z)
	action = {
	
	
	}

op opB()
	syntax = "opB"
	image = "000011110000111100001111"
	action = {
	}





op init ()
   action = {
           }
